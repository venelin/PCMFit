% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GuessInitVecParams.R
\name{GuessInitVecParams}
\alias{GuessInitVecParams}
\title{A heuristic-based guess of the optimal parameters of a model}
\usage{
GuessInitVecParams(
  o,
  regimes = as.character(PCMRegimes(o)),
  oParent = o,
  accessExpr = "",
  n = 1L,
  argsPCMParamLowerLimit = NULL,
  argsPCMParamUpperLimit = NULL,
  X = NULL,
  tree = NULL,
  SE = NULL,
  tableAnc = NULL,
  varyParams = FALSE,
  returnWithinBoundsOnly = TRUE,
  res = PCMParamRandomVecParams(o = oParent, k = PCMNumTraits(oParent), R =
    PCMNumRegimes(oParent), n = n, argsPCMParamLowerLimit = argsPCMParamLowerLimit,
    argsPCMParamUpperLimit = argsPCMParamUpperLimit),
  ...
)
}
\arguments{
\item{o}{a PCM model object.}

\item{regimes}{a vector of character strings denoting regimes in \code{o},
for which parameters must be guessed. This argument has special usage in
S3 methods and should be left to its default setting (\code{PCMRegimes(o)}).}

\item{oParent}{a PCM model object. This argument has special usage in
S3 methods and should be left to its default setting (\code{o}).}

\item{accessExpr}{a character string. This argument has special usage in
S3 methods and should be left to its default setting (\code{""}).}

\item{n}{integer denoting the number of parameter vectors to generate.}

\item{argsPCMParamLowerLimit, argsPCMParamUpperLimit}{lists of parameters
passed to \code{PCMParamLowerLimit} and \code{PCMParamUpperLimit}
respectively. (see the argument \code{returnWithinBoundsOnly}).}

\item{X}{a \code{k x N} numerical matrix with possible \code{NA} and
\code{NaN} entries. For \code{i=1,..., N}, the column \code{i} of X contains
the measured trait values for species \code{i} (the tip with integer
identifier equal to \code{i} in \code{tree}). Missing values can be either
not-available (\code{NA}) or not existing (\code{NaN}). These two values are
treated differently when calculating likelihoods (see
\code{\link[PCMBase]{PCMPresentCoordinates}}).}

\item{tree}{a phylo object with N tips.}

\item{SE}{a k x N matrix specifying the standard error for each measurement in
X. Alternatively, a k x k x N cube specifying an upper triangular k x k
factor of the variance covariance matrix for the measurement error
for each tip \code{i=1, ..., N}. When \code{SE} is a matrix, the k x k
measurement error variance matrix for a tip \code{i} is calculated as
\code{VE[, , i] <- diag(SE[, i] * SE[, i], nrow = k)}. When \code{SE} is a
cube, the way how the measurement variance matrix for a tip \code{i} is
calculated depends on the runtime option \code{PCMBase.Transpose.Sigma_x}
as follows:
\describe{
\item{if \code{getOption("PCMBase.Transpose.Sigma_x", FALSE) == FALSE} (default): }{VE[, , i] <- SE[, , i] \%*\% t(SE[, , i])}
\item{if \code{getOption("PCMBase.Transpose.Sigma_x", FALSE) == TRUE}: }{VE[, , i] <- t(SE[, , i]) \%*\% SE[, , i]}
}
Note that the above behavior is consistent with the treatment of the model
parameters \code{Sigma_x}, \code{Sigmae_x} and \code{Sigmaj_x}, which are
also specified as upper triangular factors.
Default: \code{matrix(0.0, PCMNumTraits(model), PCMTreeNumTips(tree))}.}

\item{tableAnc}{an ancestor table for tree. Default \code{NULL}.}

\item{varyParams}{logical indicating if fixed (FALSE) or varying (TRUE)
parameter values should be returned for each of the \code{n} vectors. The
default value is TRUE.}

\item{returnWithinBoundsOnly}{logical indication if the returned parameter
vectors should be within the lower and upper bound of the model.}

\item{res}{an n x p matrix where p is the number of parameters in o.
Internal use only.}

\item{...}{additional arguments passed to implementations. Currently an
N x N matrix argument named treeVCVMat can be passed which is equal to the
phylogenetic covariance matrix for tree.}
}
\value{
an n x p matrix where p is the number of parameters in o.
}
\description{
This is an S3 generic function that returns a
\code{n}x\code{PCMParamCount(o)} matrix of parameter vectors.
Implementations try to deduce parameter values based on the passed tree
and data, that should be suitable for starting points for likelihood
optimization or MCMC inference.
}
\examples{
library(PCMBase)
library(PCMFit)
modelBM.ab <- modelBM.ab.Guess <- PCM(
  PCMDefaultModelTypes()["B"], k = 2, regimes = c("a", "b"))
modelBM.ab$X0[] <- c(5, 2)
# in regime 'a' the traits evolve according to two independent BM
# processes (starting from the global vecto X0).
modelBM.ab$Sigma_x[,, "a"] <- rbind(c(1.6, 0.01),
                                    c(0, 2.4))
# in regime 'b' there is a correlation between the traits
modelBM.ab$Sigma_x[,, "b"] <- rbind(c(2.4, 0.08),
                                    c(0.0, 0.8))
modelOU.ab.Guess <- PCM(
  PCMDefaultModelTypes()["F"], k = 2, regimes = c("a", "b"))

modelMG.ab.Guess <- MixedGaussian(
k = 2, modelTypes = MGPMDefaultModelTypes(),
mapping = c(
  a = unname(MGPMDefaultModelTypes()["B"]),
  b = unname(MGPMDefaultModelTypes()["F"])))


param <- double(PCMParamCount(modelBM.ab))

# load the current model parameters into param
PCMParamLoadOrStore(modelBM.ab, param, offset=0, load=FALSE)
print(param)


# make results reproducible
set.seed(2, kind = "Mersenne-Twister", normal.kind = "Inversion")

# number of regimes
R <- 2

# number of extant tips
N <- 100

tree.a <- PCMTree(ape::rtree(n=N))
PCMTreeSetLabels(tree.a)
PCMTreeSetPartRegimes(
    tree.a, part.regime = c(`101` = "a"), setPartition = TRUE)

lstDesc <- PCMTreeListDescendants(tree.a)
splitNode <- names(lstDesc)[which(sapply(lstDesc, length) > N/2 &
   sapply(lstDesc, length) < 2*N/3)][1]

tree.ab <- PCMTreeInsertSingletons(
  tree.a, nodes = as.integer(splitNode),
  positions = PCMTreeGetBranchLength(tree.a, as.integer(splitNode))/2)
PCMTreeSetPartRegimes(
  tree.ab,
  part.regime = structure(
  c("a", "b"), names = as.character(c(N+1, splitNode))),
  setPartition = TRUE)

traits <- PCMSim(tree.ab, modelBM.ab, modelBM.ab$X0)

likFunBM <- PCMCreateLikelihood(traits, tree.ab, modelBM.ab.Guess)
likFunOU <- PCMCreateLikelihood(traits, tree.ab, modelOU.ab.Guess)
likFunMG <- PCMCreateLikelihood(traits, tree.ab, modelMG.ab.Guess)

vecGuessBM <-
  GuessInitVecParams(modelBM.ab.Guess, X = traits, tree = tree.ab)
vecGuessOU <-
  GuessInitVecParams(modelOU.ab.Guess, X = traits, tree = tree.ab)
vecGuessMG <-
  GuessInitVecParams(modelMG.ab.Guess, X = traits, tree = tree.ab)

# likelihood at true parameters used to generate the data
print(param)
likFunBM(param)

# likelihood at guessed parameter values for the BM model
print(vecGuessBM)
likFunBM(vecGuessBM)

# likelihood at guessed parameter values for the OU model
print(vecGuessOU)
likFunOU(vecGuessOU)

# likelihood at guessed parameter values for the BM model
print(vecGuessMG)
likFunMG(vecGuessMG)

# likelihood at completely random parameter values
vecRand <- PCMParamRandomVecParams(modelBM.ab.Guess, k = 2, R = 2)
likFunBM(vecRand)
}
